
@mfunction("N, D")
def rat(X, tol):
    #RAT    Rational approximation.
    #   [N,D] = RAT(X,tol) returns two integer matrices so that N./D
    #   is close to X in the sense that abs(N./D - X) <= tol*abs(X).
    #   The rational approximations are generated by truncating continued
    #   fraction expansions.   tol = 1.e-6*norm(X(:),1) is the default.
    #
    #   S = RAT(X) or RAT(X,tol) returns the continued fraction 
    #   representation as a string.
    #
    #   The same algorithm, with the default tol, is used internally
    #   by MATLAB for FORMAT RAT.
    #
    #   Class support for input X:
    #      float: double, single
    #
    #   See also FORMAT, RATS.

    #   Copyright 1984-2006 The MathWorks, Inc. 
    #   $Revision: 5.18.4.5 $  $Date: 2006/10/02 16:33:02 $

    # Approximate x by
    #
    #                              1
    #         d1 + ----------------------------------
    #                                 1
    #              d2 + -----------------------------
    #                                   1
    #                   d3 + ------------------------
    #                                      1
    #                        d4 + -------------------
    #                                        1
    #                             d5 + --------------
    #                                           1
    #                                  d6 + ---------
    #                                             1
    #                                       d7 + ----
    #                                             d8
    #
    # The d's are obtained by repeatedly picking off the integer part and 
    # then taking the reciprocal of the fractional part.  The accuracy of
    # the approximation increases exponentially with the number of terms
    # and is worst when x = sqrt(2).  For x = sqrt(2), the error with k
    # terms is about 2.68*(.173)^k, which is
    #
    #         1    4.6364e-01
    #         2    8.0210e-02
    #         3    1.3876e-02
    #         4    2.4006e-03
    #         5    4.1530e-04
    #         6    7.1847e-05
    #         7    1.2430e-05
    #         8    2.1503e-06
    #         9    3.7201e-07
    #        10    6.4357e-08

    if nargin < 2:
        tol = 1.e-6 * norm(X(isfinite(X)), 1)
    end
    if not isreal(X):
        if norm(imag(X), 1) <= tol * norm(real(X), 1):
            X = real(X)
        elif nargout > 1:
            [NR, DR] = rat(real(X))
            [NI, DI] = rat(imag(X))
            D = lcm(DR, DI)
            N = D /eldiv/ DR *elmul* NR + D /eldiv/ DI *elmul* NI * i
            return
        else:
            N = strvcat(rat(real(X)), mstring(' +i* ...'), rat(imag(X)))
            return
        end
    end
    if nargout > 1:
        N = zeros(size(X), mclass(X))
        D = zeros(size(X), mclass(X))
    else:
        N = zeros(0, 0, mclass(X))
    end
    for j in mslice[1:numel(X)]:
        x = X(j)
        if not isfinite(x):             # Special case for inf, -inf, NaN
            if nargout <= 1:
                s = int2str(x)
                k = length(s) - size(N, 2)
                N = char(mcat([N, mstring(' ') * ones(j - 1, k), OMPCSEMI, s, mstring(' ') * ones(1, -k)]))
            else:
                if not isnan(x):
                    N(j).lvalue = sign(x); print N
                else:
                    N(j).lvalue = 0; print N
                end
                D(j).lvalue = 0
            end
        else:
            k = 0
            C = mcat([1, 0, OMPCSEMI, 0, 1])                # [n(k) n(k-1); d(k) d(k-1)];
            while 1:
                k = k + 1
                neg = x < 0
                d = round(x)
                if not isinf(x):
                    x = x - d
                    C = mcat([C * mcat([d, OMPCSEMI, 1]), C(mslice[:], 1)])
                else:                     # Special case for +/- inf
                    C = mcat([mcat([x, OMPCSEMI, 0]), C(mslice[:], 1)])
                end
                if nargout <= 1:
                    d = int2str(abs(d))
                    if neg:
                        d = mcat([mstring('-'), d]); print d
                    end
                    if k == 1:
                        s = d
                    elif k == 2:
                        s = mcat([s, mstring(' + 1/('), d, mstring(')')])
                    else:
                        p = find(s == mstring(')'), 1)
                        s = mcat([s(mslice[1:p - 1]), mstring(' + 1/('), d, mstring(')'), s(mslice[p:p + k - 3])])
                    end
                end
                if (x == 0) or (abs(C(1, 1) / C(2, 1) - X(j)) <= max(tol, eps(X(j)))):
                    break
                end
                x = 1 / x
            end
            if nargout > 1:
                N(j).lvalue = C(1, 1) / sign(C(2, 1))
                D(j).lvalue = abs(C(2, 1))
            else:
                k = length(s) - size(N, 2)
                N = char(mcat([N, mstring(' ') * ones(j - 1, k), OMPCSEMI, s, mstring(' ') * ones(1, -k)]))
            end
        end
    end
